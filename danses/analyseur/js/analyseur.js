dances = [
  {
    "name": "Valse lente",
    "bpm_range": [78, 115],
    "time_signature": "3/4",
    "energy_range": [0.1, 0.25],
    "onset_rate_range": [2,3.5],
    "sc_range": [80, 200],
    "flatness_range": [0.75, 0.85], 
    "zcr_range": [0.03, 0.06], 
    "accent_profile" : [1.0, 0.2, 0.0],
    "ibi_range": [0.5, 0.8],
    "rhythm_pattern": [1, 0, 0.6, 0, 0.4, 0],
    "swing_ratio_range": [1.0, 1.1],
    "mfcc_profile": [-581.17, 156.02, 0.99, 14.16, -9.63, -4.23, -8.43, -0.81, -8.74, -3.27, -4.86, -3.97, -2.19],
    "danceability": 1,
    "beat_loudness": 0.14,
    "bpm_histogram": [70, 74, 82, 90],
    "notes": "Danse fluide, temps marqués, Accent sur le 1er temps"
  },
  {
    "name": "Tango",
    "bpm_range": [120, 140],
    "time_signature": "2/4",
    "energy_range": [0.14, 0.25],
    "onset_rate_range": [2.1, 3.6],
    "sc_range": [100, 100],
    "flatness_range": [0.62, 0.82], 
    "zcr_range": [0.025, 0.058],
    "accent_profile" : [1, 0.26, 0.0000002],
    "ibi_range": [0.45, 0.55],
    "rhythm_pattern": [0.94, 0.95, 0.92, 0.94, 0.99, 0.97],
    "swing_ratio_range": [1.0, 1.1],
     "mfcc_profile": [-599.6, 170.2, -27.1, 18.4, -8.1, -5.7,
      -7.8, -2.0, -1.1, -1.3, -3.0, -1.3, -0.1],
     "danceability": 1.2,
    "beat_loudness": 0.18,
    "bpm_histogram": [123, 126, 128, 138],
    "notes": "Accents très marqués, Phrasé staccato, arrêts nets (cuts)"
  },
  {
    "name": "Valse viennoise",
    "bpm_range": [168, 180],
    "time_signature": "3/4",
    "energy_range": [3000, 7000],
    "onset_rate_range": [2500,4500],
    "sc_range": [100, 200],
    "flatness_range": [0.12, 0.3], 
    "zcr_range": [0.03, 0.05],
    "accent_profile" : [1.0, 0.3, 0.8, 0.2],
    "ibi_range": [0.5, 0.55],
    "rhythm_pattern": [1, 0, 0.8, 0, 0.6, 0],
    "swing_ratio_range": [1.0, 1.2],
     "mfcc_profile": [220, 90, 25, 0, -5, -10, -18, -16, -14, -12, -10, -8, -6],
     "danceability": 0.7,
     "beat_loudness": 0.4,
         "bpm_histogram": [150, 300],
    "notes": "Tempo rapide en 3 temps"
  },
  {
    "name": "Slow fox",
    "bpm_range": [112, 120],
    "time_signature": "4/4",
    "energy_range": [3000, 6000],
    "onset_rate_range": [1500,2500],
    "sc_range": [100, 250],
    "flatness_range": [0.1, 0.3], 
    "zcr_range": [0.03, 0.05],
    "accent_profile" : [1.0, 0.5, 0.8, 0.4],
    "ibi_range": [0.4, 0.45],
    "rhythm_pattern": [1, 0.7, 0.5, 0.8, 0.4, 0.6],
    "swing_ratio_range": [1.0, 1.2],
     "mfcc_profile": [210, 85, 22, -2, -8, -14, -20, -18, -16, -14, -12, -10, -8],
     "danceability": 0.65,
     "beat_loudness": 0.4,
         "bpm_histogram": [83, 166],
    "notes": "Sensation de glissement"
  },
  {
    "name": "Quickstep",
    "bpm_range": [192, 208],
    "time_signature": "4/4",
   "energy_range": [5000, 9000],
    "onset_rate_range": [3000,5500],
    "sc_range": [200, 400],
    "flatness_range": [0.2, 0.4], 
    "zcr_range": [0.05, 0.08],
    "accent_profile" : [1.0, 0.2, 0.5],
    "ibi_range": [0.4, 0.45],
    "rhythm_pattern": [1, 0, 0.6, 0, 0.5, 0],
    "swing_ratio_range": [1.0, 1.3],
     "mfcc_profile": [230, 95, 28, 2, -4, -10, -16, -14, -12, -10, -8, -6, -4],
     "danceability": 0.8,
     "beat_loudness": 0.6,
         "bpm_histogram": [167, 333],
    "notes": "Très dynamique"
  },
  {
    "name": "Cha-cha-cha",
    "bpm_range": [120, 130],
    "time_signature": "4/4",
    "energy_range": [6000, 8000],
    "onset_rate_range": [2500,4500],
    "sc_range": [200, 350],
    "flatness_range": [0.25, 0.45], 
    "zcr_range": [0.06, 0.09],
    "accent_profile" : [1.0, 0.6, 0.8, 0.5, 0.7],
    "ibi_range": [0.4, 0.45],
    "rhythm_pattern": [1, 0.6, 0.8, 0.5, 0.7],
    "swing_ratio_range": [1.0, 1.2],
     "mfcc_profile": [240, 90, 26, 1, -3, -7, -11, -13, -15, -17, -19, -21, -23],
     "danceability": 0.85,
     "beat_loudness": 0.7,
         "bpm_histogram": [200, 400],
    "notes": "Accent sur les temps faibles"
  },
  {
    "name": "Rumba",
    "bpm_range": [90, 104],
    "time_signature": "4/4",
    "energy_range": [2000, 6000],
    "onset_rate_range": [1200,2500],
    "sc_range": [150, 500],
    "flatness_range": [0.15, 0.35], 
    "zcr_range": [0.02, 0.05],
    "accent_profile" : [1.0, 0.2, 0.9, 0.3],
    "ibi_range": [0.5, 0.6],
    "rhythm_pattern": [1, 0, 0.9, 0.3],
    "swing_ratio_range": [1.0, 1.2],
     "mfcc_profile": [245, 92, 27, 1, -3, -6, -9, -12, -15, -18, -21, -24, -27],
     "danceability": 0.75,
     "beat_loudness": 0.6,
         "bpm_histogram": [125, 250],
    "notes": "Tempo lent, accents subtils"
  },
  {
    "name": "Samba",
    "bpm_range": [96, 104],
    "time_signature": "2/4",
    "energy_range": [6000, 10000],
    "onset_rate_range": [3500,5000],
    "sc_range": [300, 500],
    "flatness_range": [0.3, 0.5], 
    "zcr_range": [0.08, 0.12],
     "accent_profile" : [1.0, 0.5, 0.9, 0.4, 0.8],
    "ibi_range": [0.45, 0.5],
    "rhythm_pattern": [1, 0.4, 0.9, 0.3, 0.8],
    "swing_ratio_range": [1.4, 1.7],
      "mfcc_profile": [260, 110, 36, 9, 5, 1, -3, -7, -11, -15, -19, -23, -27],
      "danceability": 0.85,
      "beat_loudness": 0.7,
          "bpm_histogram": [200, 400],
    "notes": "Caractère rebondissant"
  },
  {
    "name": "Paso doble",
    "bpm_range": [112, 124],
    "time_signature": "2/4",
    "energy_range": [7000, 10000],
    "onset_rate_range": [3000,4500],
    "sc_range": [250, 400],
    "flatness_range": [0.2, 0.4], 
    "zcr_range": [0.05, 0.08],
     "accent_profile" : [1.0, 0.3, 1.0, 0.2],
    "ibi_range": [0.45, 0.55],
    "rhythm_pattern": [1, 0.3, 1, 0.2],
    "swing_ratio_range": [1.0, 1.1],
     "mfcc_profile": [270, 115, 38, 10, 6, 2, -2, -6, -10, -14, -18, -22, -26],
     "danceability": 0.6,
     "beat_loudness": 0.75,
         "bpm_histogram": [183, 366],
    "notes": "Rythme martial"
  },
  {
    "name": "Jive",
    "bpm_range": [168, 184],
    "time_signature": "4/4",
    "energy_range": [8000, 10000],
    "onset_rate_range": [4000,6500],
    "sc_range": [400, 600],
    "flatness_range": [0.3, 0.5], 
    "zcr_range": [0.1, 0.16],
     "accent_profile" : [1.0, 0.6, 0.9, 0.7],
    "ibi_range": [0.4, 0.45],
    "rhythm_pattern": [1, 0.6, 0.9, 0.7],
    "swing_ratio_range": [1.8, 2.2],
     "mfcc_profile": [255, 105, 35, 8, 4, 0, -4, -8, -12, -16, -20, -24, -28],
     "danceability": 0.9,
     "beat_loudness": 0.8,
         "bpm_histogram": [250, 500],
    "notes": "Sauts, rebonds"
  },
  {
    "name": "Salsa",
    "bpm_range": [150, 250],
    "time_signature": "4/4",
    "energy_range": [6000, 9000],
    "onset_rate_range": [4000, 6000],
    "sc_range": [350, 800],
    "flatness_range": [0.3, 0.5], 
    "zcr_range": [0.08, 0.2],
    "accent_profile" : [1.0, 0.5, 0.8, 0.2, 0.7],
    "ibi_range": [0.45, 0.5],
    "rhythm_pattern": [1, 0.5, 0.8, 0.2, 0.7],
    "swing_ratio_range": [1.3, 1.6],
     "mfcc_profile": [250, 100, 30, 6, 2, -2, -6, -10, -14, -18, -22, -26, -30],
    "danceability": 0.9,
    "beat_loudness": 0.8,
    "bpm_histogram": [200, 400],
    "notes": "Claves caractéristiques"
  },
  {
    "name": "Rock 4 temps",
    "bpm_range": [120, 176],
    "time_signature": "4/4",
    "energy_range": [5000, 8000],
    "onset_rate_range": [2500,4000],
    "sc_range": [300, 450],
    "flatness_range": [0.25, 0.45], 
    "zcr_range": [0.07, 0.1],
    "accent_profile" : [1.0, 0.7, 0.9, 0.6],
    "ibi_range": [0.45, 0.55],
    "rhythm_pattern": [1, 0.7, 0.9, 0.6],
    "swing_ratio_range": [1.6, 2.0],
    "mfcc_profile": [240, 98, 29, 5, 1, -3, -7, -11, -15, -19, -23, -27, -31],
    "danceability": 0.88,
    "beat_loudness": 0.85,
    "bpm_histogram": [200, 400],
    "notes": "Accent tous les 2 temps"
  }
]






document.getElementById("audio-input").addEventListener("change", async function (event) {
    const output = document.getElementById("output");
    output.innerHTML = "Analyse en cours... Cela peut prendre quelques minutes";
    const audioPlayer = document.getElementById("audioPlayer");
    

    const file = event.target.files[0];
    if (!file) return;

    if (!file.name.endsWith(".wav")) {
        alert("Veuillez sélectionner un fichier .wav");
        return;
    }

    audioPlayer.style.display = "block";
    

    const audioContext = new AudioContext();
    const arrayBuffer = await file.arrayBuffer();
    const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);

    const totalDuration = audioBuffer.duration;
    const segmentDuration = 20; // secondes
    const nbSegments = 4;
    const startOffset = 10; // on saute les 10 premières secondes

    const segments = [];

    for (let i = 0; i < nbSegments; i++) {
        const segmentStart = startOffset + i * ((totalDuration - startOffset) / nbSegments);
        if (segmentStart + segmentDuration > totalDuration) break;

        const startSample = Math.floor(segmentStart * audioBuffer.sampleRate);
        const endSample = Math.floor((segmentStart + segmentDuration) * audioBuffer.sampleRate);

        const segmentLength = endSample - startSample;
        const segmentBuffer = audioBuffer.getChannelData(0).slice(startSample, endSample);

        // Création d'un Buffer WAV depuis les samples
        const wavBlob = bufferToWavBlob(segmentBuffer, audioBuffer.sampleRate);
        segments.push(wavBlob);
       
    }
    segmentsResult = new Array;
     analyserSegments(segments);
});

function fusionnerSegments(segments) {
    
    const fusion = {};
    const n = segments.length;
    
    const bpmMoyennePondereeBPM = bpmMoyennePonderee(segments);
    fusion["bpm"] = bpmMoyennePondereeBPM;
// Trouver le segment dont le BPM est le plus proche de la moyenne pondérée
const segmentCible = segments.reduce((closest, s) => {
    return (Math.abs(s.bpm - bpmMoyennePondereeBPM) < Math.abs(closest.bpm - bpmMoyennePondereeBPM)) ? s : closest;
}, segments[0]);
fusion["bpm_confidence"] = segmentCible.beats_confidence;
    // Clés scalaires simples
    const scalaires = ["energy", "onset_rate", "sc", "flatness", "zcr", "ibi", "swing_ratio"];

    scalaires.forEach(clé => {
        const valeurs = segments
            .map(seg => seg?.[clé])
            .filter(val => typeof val === "number" && !isNaN(val));
        fusion[clé] = valeurs.length > 0 ? valeurs.reduce((a, b) => a + b, 0) / valeurs.length : null;
    });

    // Danceability avec moyenne pondérée (beats_confidence)
    const danceValues = [];
    let totalWeight = 0;
    for (let i = 0; i < n; i++) {
        const val = segments[i]?.danceability;
        const conf = segments[i]?.beats_confidence;
        if (typeof val === "number" && typeof conf === "number") {
            danceValues.push(val * conf);
            totalWeight += conf;
        }
    }
    fusion["danceability"] = totalWeight > 0 ? danceValues.reduce((a, b) => a + b, 0) / totalWeight : null;

    // beat_loudness : moyenne par index
 const beat_loudnessArrays = segments.map(s => s.beat_loudness?.[0]).filter(Boolean);

  if (beat_loudnessArrays.length > 0) {
    const longueur = beat_loudnessArrays[0].length;

    const moyennebeat_loudness = Array.from({ length: longueur }, (_, i) => {
    const valeursValides = beat_loudnessArrays
    .map(arr => arr[i])
    .filter(v => typeof v === 'number' && !isNaN(v));
    
    const somme = valeursValides.reduce((acc, val) => acc + val, 0);
    return valeursValides.length > 0 ? somme / valeursValides.length : 0;
});
    console.log(moyennebeat_loudness);
   if (Array.isArray(moyennebeat_loudness) && moyennebeat_loudness.length > 0) {
  const valeursValides = moyennebeat_loudness.filter(val => typeof val === 'number' && !isNaN(val));
  const moyenneGlobale = valeursValides.reduce((sum, val) => sum + val, 0) / valeursValides.length;
  fusion["beat_loudness"] = moyenneGlobale;
}

    fusion["beat_loudness_array"] = moyennebeat_loudness;
  } else {
    fusion["beat_loudness_array"] = null;
  }


    // Moyenne des vecteurs
    const vecteurs = ["accent_profile", "rhythm_pattern", "mfcc_profile"];
    vecteurs.forEach(clé => {
        const vecteursValides = segments
            .map(seg => Array.isArray(seg?.[clé]) ? seg[clé] : null)
            .filter(arr => arr && arr.every(val => typeof val === "number"));

        if (vecteursValides.length === 0) {
            fusion[clé] = null;
            return;
        }

        const longueur = vecteursValides[0].length;
        const moyennes = [];

        for (let i = 0; i < longueur; i++) {
            const valeurs = vecteursValides
                .map(v => v[i])
                .filter(val => typeof val === "number");
            const moyenne = valeurs.length > 0 ? valeurs.reduce((a, b) => a + b, 0) / valeurs.length : null;
            moyennes.push(moyenne);
        }

        fusion[clé] = moyennes;
    });

  let mainBpmTotal = 0;
  let mainBpmCount = 0;
  const histogramValues = [];

  for (const segment of segments) {console.log("l.376");
    console.log("Segment complet :", segment);
  console.log("Type segment[0] :", typeof segment.bpm, "Valeur :", segment.bpm);
  console.log("Type segment[4] :", typeof segment.bpm_histogram, "Valeur :", segment.bpm_histogram);

      if (typeof segment.bpm === 'number' && !isNaN(segment.bpm)) {console.log("l.381");
      mainBpmTotal += segment.bpm;
      mainBpmCount += 1;
    }

    // 2. Histogram: segment[4] (vecteur de BPM)
    if (Array.isArray(segment.bpm_histogram) && segment.bpm_histogram.length > 0) {
      const rounded = segment.bpm_histogram
        .map(v => Math.round(v))
        .filter(v => typeof v === 'number' && !isNaN(v));
      histogramValues.push(...rounded);
    }
  }
console.log(mainBpmTotal, mainBpmCount);
  // Calcul final du BPM moyen principal
  fusion.mainBPM = mainBpmCount > 0 ? mainBpmTotal / mainBpmCount : null;

  // Construction de bpm_histogram (les BPM les plus fréquents dans l'histogramme)
  if (histogramValues.length > 0) {
   console.log("l.398");
    const bpmFreqMap = {};

    for (const value of histogramValues) {
      bpmFreqMap[value] = (bpmFreqMap[value] || 0) + 1;
    }

    const topHistogramBPMs = Object.entries(bpmFreqMap)
      .sort((a, b) => b[1] - a[1])   // tri par fréquence décroissante
      .slice(0, 4)                   // on garde les 4 plus fréquents
      .map(([bpmStr]) => parseInt(bpmStr));

    fusion.bpm_histogram = topHistogramBPMs;
  } else {
    console.warn("❗ Aucune valeur d’histogramme trouvée dans segment[4].");
    fusion.bpm_histogram = [];
  }
  
  
    return fusion;
}




async function analyserSegments(segments) {
    for (let i = 0; i < segments.length; i++) {
    const formData = new FormData();
    const file = new File([segments[i]], `segment${i + 1}.wav`, { type: "audio/wav" });
    formData.append("audio", file);


    try {
        const response = await fetch("http://192.168.1.62:5000/analyse", {
            method: "POST",
            body: formData
        });

        const result = await response.json();
        segmentsResult.push(result);
        console.log(`✅ Résultat segment ${i + 1} :`, result);
    } catch (error) {
        console.error(`❌ Erreur segment ${i + 1} :`, error);
    }
}



const fusionFinale = fusionnerSegments(segmentsResult);
console.log("Résultat fusionné :", fusionFinale);

const { bestMatch, allMatches } = compareResultToDancesWeighted(fusionFinale, dances);
console.log("Danse probable :", bestMatch.name, "avec erreur =", bestMatch.error);
console.table(allMatches);
}

function normalizeRangeError(value, range) {
  if (value < range[0]) return (range[0] - value) / (range[1] - range[0]);
  if (value > range[1]) return (value - range[1]) / (range[1] - range[0]);
  return 0;
}

function normalizeVectorDiff(v1, v2) {
  const len = Math.min(v1.length, v2.length);
  let diff = 0;
  for (let i = 0; i < len; i++) {
    // On suppose que les valeurs sont déjà dans une échelle comparable ou on peut normaliser ici si besoin
    diff += Math.abs(v1[i] - v2[i]);
  }
  return diff / len; // Moyenne de l’écart absolu par élément (normalisé sur la taille)
}

function compareResultToDancesWeighted(result, dances) {
  const weights = {
    energy: 0.2,
    onset_rate: 0.15,
    ibi: 0.1,
    zcr: 0.05,
    swing_ratio: 0.05,
    sc: 0.1,
    danceability: 0.1,
    accent_profile: 0.15,
    mfcc_profile: 0.05,
    rhythm_pattern: 0.15,
    time_signature: 0.2,
    beat_loudness: 0.1,
    bpm_histogram: 0.1,
    flatness: 0.05, 
  };


  const errors = dances.map(dance => {
    let error = 0;
    error += weights.energy * normalizeRangeError(result.energy, dance.energy_range);
    error += weights.onset_rate * normalizeRangeError(result.onset_rate, dance.onset_rate_range);
    error += weights.ibi * normalizeRangeError(result.ibi, dance.ibi_range);
    error += weights.zcr * normalizeRangeError(result.zcr, dance.zcr_range);
    error += weights.swing_ratio * normalizeRangeError(result.swing_ratio, dance.swing_ratio_range);
    error += weights.sc * normalizeRangeError(result.sc, dance.sc_range);
    error += weights.danceability * Math.abs(result.danceability - dance.danceability);
console.log()
    error += weights.bpm_histogram * normalizeVectorDiff(result.bpm_histogram, dance.bpm_histogram);
    error += weights.accent_profile * normalizeVectorDiff(result.accent_profile, dance.accent_profile);
    error += weights.mfcc_profile * normalizeVectorDiff(result.mfcc_profile, dance.mfcc_profile);
    error += weights.rhythm_pattern * normalizeVectorDiff(result.rhythm_pattern, dance.rhythm_pattern);
    error += weights.beat_loudness * Math.abs(result.beat_loudness - dance.beat_loudness);
    error += weights.flatness * normalizeRangeError(result.flatness, dance.flatness_range);
    // Time signature : pénalité fixe
    const estimatedTimeSig = estimateTimeSignature(result);
    console.log("time_signature", estimatedTimeSig);
    if (dance.time_signature !== estimatedTimeSig) {
      error += weights.time_signature * 1; // pénalité 1 (à ajuster)
    }

    return {
      name: dance.name,
      error: Math.round(error * 1000) / 1000
    };
  });

  errors.sort((a, b) => a.error - b.error);
  return {
    bestMatch: errors[0],
    allMatches: errors
  };
}



function bpmMoyennePonderee(segments) {
    let total = 0;
    let poidsTotal = 0;

    for (const s of segments) {
        if (s.bpm && s.beats_confidence) {
            total += s.bpm * s.beats_confidence;
            poidsTotal += s.beats_confidence;
        }
    }

    return poidsTotal > 0 ? total / poidsTotal : null;
}

function hasTriplePulse(rhythm_pattern) {
  // Rythme ternaire régulier, type 3/4
  return (
    Math.abs(rhythm_pattern[0] - rhythm_pattern[3]) < 0.05 &&
    Math.abs(rhythm_pattern[1] - rhythm_pattern[4]) < 0.05 &&
    Math.abs(rhythm_pattern[2] - rhythm_pattern[5]) < 0.05
  );
}

function hasTriplePulse(rhythm_pattern) {
  // Détection d’un motif ternaire (ex : 3/4)
  return (
    Math.abs(rhythm_pattern[0] - rhythm_pattern[3]) < 0.05 &&
    Math.abs(rhythm_pattern[1] - rhythm_pattern[4]) < 0.05 &&
    Math.abs(rhythm_pattern[2] - rhythm_pattern[5]) < 0.05
  );
}

function hasTriplePulse(rhythm_pattern) {
  return (
    Math.abs(rhythm_pattern[0] - rhythm_pattern[3]) < 0.05 &&
    Math.abs(rhythm_pattern[1] - rhythm_pattern[4]) < 0.05 &&
    Math.abs(rhythm_pattern[2] - rhythm_pattern[5]) < 0.05
  );
}

function estimateTimeSignature(result) {
  const ap = result.accent_profile;
  const onsetRate = result.onset_rate;
  const ibi = result.ibi;

  console.log("accent_profile:", ap);
  console.log("onset_rate:", onsetRate);
  console.log("ibi:", ibi);

  if (!ap || ap.length !== 3) return "unknown";

  const [a1, a2, a3] = ap;
  const total = a1 + a2 + a3;
  const r1 = a1 / total;
  const r2 = a2 / total;
  const r3 = a3 / total;

  // Juste une règle simple basée sur ratio des accents
  if (r3 > 0.2) return "3/4";       // valse lente (ternaire)
  if (r1 > 0.5 && r2 > 0.2) return "2/4"; // tango (binaire avec accent fort)
  if (r1 < 0.5 && r2 < 0.3 && r3 < 0.1) return "4/4"; // autres

  return "unknown";
}





// === Fonction utilitaire : transforme Float32Array en WAV Blob (mono) ===
function bufferToWavBlob(buffer, sampleRate) {
    const wavBuffer = encodeWav(buffer, sampleRate);
    return new Blob([wavBuffer], { type: "audio/wav" });
}

function encodeWav(samples, sampleRate) {
    const buffer = new ArrayBuffer(44 + samples.length * 2);
    const view = new DataView(buffer);

    function writeString(view, offset, string) {
        for (let i = 0; i < string.length; i++) {
            view.setUint8(offset + i, string.charCodeAt(i));
        }
    }

    const numChannels = 1;
    const bitsPerSample = 16;

    writeString(view, 0, "RIFF");
    view.setUint32(4, 36 + samples.length * 2, true);
    writeString(view, 8, "WAVE");
    writeString(view, 12, "fmt ");
    view.setUint32(16, 16, true); // Subchunk1Size
    view.setUint16(20, 1, true);  // PCM
    view.setUint16(22, numChannels, true);
    view.setUint32(24, sampleRate, true);
    view.setUint32(28, sampleRate * numChannels * bitsPerSample / 8, true);
    view.setUint16(32, numChannels * bitsPerSample / 8, true);
    view.setUint16(34, bitsPerSample, true);
    writeString(view, 36, "data");
    view.setUint32(40, samples.length * 2, true);

    // PCM 16-bit
    for (let i = 0; i < samples.length; i++) {
        let s = Math.max(-1, Math.min(1, samples[i]));
        view.setInt16(44 + i * 2, s < 0 ? s * 0x8000 : s * 0x7FFF, true);
    }

    return view;
}
